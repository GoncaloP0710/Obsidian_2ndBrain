2025-03-30 20:37

Status: #done 

Tags: [[Deteção e Tolerância a Intrusões]] [[Byzantine]] [[PBFT – Practical Byzantine Fault Tolerance]] 

# BFT - Improving Resource Efficiency

BFT in Homogeneous Systems is Expensive
- At least 3f+1 replicas
- At least 3 communication steps to establish agreement (non-speculative normal case operation)

Is it possible to do better for a practical protocol?
- less than 3f+1 replicas to tolerate f Byzantine faults?
	- Homogeneous non-synchronous systems require 3f+1 replicas
- less than 3 communication steps to establish agreement
	- It is possible to consensus with 2 communication steps if there are 5f+1 replicas
Hybrid distributed systems with local trusted components can do both.

## System Model

- Eventually synchronous system
- Authenticated and **reliable** channels
- Up to f replicas and an unbounded number of clients can be subject to Byzantine failures
- n ≥ 2f + 1 replicas
- *Local Trusted Component* (LTC) on replicas
- Secure hash function

## Local Trusted Component: (USIG - Unique Sequential Identifier Generator)

USIG is a “minimal” LTC which contains:
- A crypto system for authenticating its outputs
- A monotonic counter

The identifiers must satisfy two properties:
- *Uniqueness*: the same identifier is never assigned to two different messages
- *Sequentiality*: an identifier (except for the first one) is a direct successor of the identifier obtained in the previous access to the component

Operations supported
- Assigns a counter value c_val to a message m
- Verifies if UI was generated by createUI(m) on the USIG.

**More important**: if your hosts have a TPM or an SGX-enabled processor, you can tolerate Byzantine faults with roughly the same costs of tolerating crashes.

*MinPBFT*
- 2f+1 instead of 3f+1 replicas
- 2 steps instead of 3 on the normal case

*MinZyzzyva*
- 2f+1 instead of 3f+1 replicas

![[BFT - Improving Resource Efficiency 1.png]]

#### MinPBFT – Normal Case

![[BFT - Improving Resource Efficiency 2.png]]

- Primary defines the order (USIG)
	- The global seq. Number is the USIG counter value assigned to the operation being ordered
- Servers accepted f+1 commits
- Execution follows the order on PREPARE’ UI
- Client waits for f+1 matching replies

#### MinPBFT – View Change

![[BFT - Improving Resource Efficiency 3.png]]

- After receiving a request, a server starts a timer
- If it expires, server sends REQ-VIEW-CHANGE
- When f+1 REQ-VIEW-CHANGE are received
	- v = v + 1
	- sends VIEW-CHANGE with its current state
- When f+1 VIEW-CHANGE are received
	- Primary of v+1 sends a NEW-VIEW to prepare pending requests
- VIEW-CHANGE and NEW-VIEW messages are validated by an UI

#### MinPBFT – Why does it work?

Uses 2f+1 replicas with quorums of size f+1.
There is a single replica in the intersection of any two quorums.
What if this replica is faulty?
- It cannot lie because every value is associated with a UI
- Different values will have different UIs
Practical effects:
- A primary cannot send two PREPARE messages with different contents and the same sequence number (UI)
- A backup cannot lie about the value proposed by the primary

### USIG Implementation (VM USIG)

![[BFT - Improving Resource Efficiency 4.png]]

The **BFT protocol + application** runs on a **untrusted virtual machine** that have access to the outside network.
The **USIG** is implemented as a daemon on a **trusted virtual machine**.
They communicate by TCP sockets.

### USIG Implementation (TPM USIG)

![[BFT - Improving Resource Efficiency 5.png]]

A public-key (2048-bit RSA) implementation of the USIG service.
The private key and the counter are stored in the TPM.
BFT protocol access a TPM driver to issue commands.

# References

https://moodle.ciencias.ulisboa.pt/pluginfile.php/585155/mod_resource/content/5/intol-06-bftsmr-advanced.pdf